using System;
using System.Collections.Generic;
using System.Web;
using System.IO;
using System.Threading;
using System.Text;

/// <summary>
/// server_code 的摘要描述
/// </summary>
public static class server_code {
	#region 傳回字串，包含指定的從字串左邊的字元數 +static string Left(this string str, int ln)
	public static string Left(this string str, int ln) {
		string sret = str.Substring(0, Math.Min(ln, str.Length));
		return sret;
	}
	#endregion

	#region 傳回字串，包含指定的從字串右邊的字元數 +static string Right(this string str, int ln)
	public static string Right(this string str, int ln) {
		ln = Math.Max(ln, 0);
		if (str.Length > ln) {
			return str.Substring(str.Length - ln, ln);
		} else {
			return str;
		}
	}
	#endregion

	#region 將&#nnnn;轉成word用格式 +static string ToXmlUnicode(this string str)
	/// <summary>
	/// 將&amp;#nnnn;轉成word用格式
	/// </summary>
	public static string ToXmlUnicode(this string str) {
		return str.ToXmlUnicode(false);
	}
	#endregion

	#region 將&#nnnn;轉成word用格式 +static string ToXmlUnicode(this string str, bool isEng)
	/// <summary>
	/// 將&amp;#nnnn;轉成word用格式
	/// </summary>
	public static string ToXmlUnicode(this string str, bool isEng) {
		foreach (System.Text.RegularExpressions.Match m
			in System.Text.RegularExpressions.Regex.Matches(str, "&#(?<ncr>\\d+?);"))
			str = str.Replace(m.Value, char.ConvertFromUtf32(int.Parse(m.Groups["ncr"].Value)).ToString());
		str = HttpUtility.HtmlDecode(str);
		//str = str.Replace("&", "&amp;");
		//str = str.Replace("<", "&lt;");
		if (isEng) {//防止英文欄位只能半型
			str = str.Replace("’", "'");
			str = str.Replace("＆", "&");
		}
		//ret=str.Replace(">","&gt;");
		//ret=str.Replace("'","&apos;");
		//ret=str.Replace("""","&quot;");

		return str.Trim();
	}
	#endregion

	#region 將難字轉成&#nnnn; +static string ToBig5
	/// <summary>
	/// 將難字轉成&amp;#nnnn;
	/// </summary>
	public static string ToBig5(this string str) {
		StringBuilder sb = new StringBuilder();
		Encoding big5 = Encoding.GetEncoding("big5");
		Encoding utf32 = Encoding.UTF32;

        if (str == null) return str;

        //有包含用到第二輔助平面的unicode要特別處理
		if (str.Len() != str.Length) {
			for (int i = 0; i < str.Len(); i++) {
				string c = str.Substr(i, 1);

				//string cInBig5 = big5.GetString(Encoding.Convert(utf32, big5, utf32.GetBytes(c)));
				string cInBig5 = big5.GetString(big5.GetBytes(c.ToCharArray()));
				//HttpContext.Current.Response.Write("\r\n<HR>　　c　　　　　→" + c);
				//HttpContext.Current.Response.Write("\r\n<HR>　　cInBig5　　　　　→" + cInBig5);
				//if (c != "?" && cInBig5.IndexOf('?') > -1) {
				if (c != cInBig5) {
                    if (cInBig5 == "??") {//用到第二輔助平面的unicode
						sb.AppendFormat("&#{0};", c.GetCharCode());
                    } else {
                        sb.AppendFormat("&#{0};", Convert.ToInt32(Convert.ToChar(c)));
                        //sb.Append(HttpUtility.HtmlEncode(c));
                    }
				} else {
					sb.Append(c);
				}
			}
		} else {
		foreach (char c in str) {
			string cInBig5 = big5.GetString(big5.GetBytes(new char[] { c }));
				//if (c != '?' && cInBig5 == "?") {
				if (c.ToString() != cInBig5) {
                    sb.AppendFormat("&#{0};", Convert.ToInt32(c));
                    //sb.Append(HttpUtility.HtmlEncode(c.ToString()));
				} else {
				sb.Append(c);
		}
			}
		}
		return sb.ToString();
	}
	#endregion

	#region 截取字串,指定長度 +static string CutStr(this string str, int len)
	/// <summary>
	/// 截取字串,指定長度
	/// </summary>
	/// <param name="len">截取長度</param>
	/// <returns></returns>
	public static string CutStr(this string str, int len) {
		if (str == null || str.Length == 0 || len <= 0) {
			return string.Empty;
		}

		int orgLen = str.Length;

		int clen = 0;
		//計算要substr的長度
		while (clen < len && clen < orgLen) {
			//每遇到一個中文，則將目標長度減一。
			if ((int)str[clen] > 128) { len--; }
			clen++;
		}

		if (clen < orgLen) {
			return str.Substring(0, clen);
		} else {
			return str;
		}
	}
	//public static string CutStr(this string str, int totalWidth) {
	//	Encoding l_Encoding = Encoding.GetEncoding("big5", new EncoderExceptionFallback(), new DecoderReplacementFallback(""));
	//	byte[] strut8 = Encoding.Unicode.GetBytes(str);
	//	//byte[] strbig5 = Encoding.Convert(Encoding.Unicode, Encoding.GetEncoding("big5"), strut8);
	//	//byte[] strbig5 = Encoding.GetEncoding("big5").GetBytes(str);
	//	byte[] strbig5 = l_Encoding.GetBytes(str);
	//	return l_Encoding.GetString(strbig5, 0, totalWidth);
	//
	//	//Encoding l_Encoding = Encoding.GetEncoding("big5", new EncoderExceptionFallback(), new DecoderReplacementFallback(""));
	//	//byte[] l_byte = l_Encoding.GetBytes(str);
	//	//HttpContext.Current.Response.Write("CutStr=" + str + "(" + l_byte.Length + ")" + Environment.NewLine);
	//	//return l_Encoding.GetString(l_byte, 0, totalWidth);
	//}
	#endregion

	#region 字串靠右對齊 +static string PadLeftCHT(this string str, int totalWidth, char paddingChar)
	/// <summary>
	/// 字串靠右對齊，以指定的字元在左側補足長度，超過則截字(中文算2碼)。
	/// </summary>
	/// <param name="totalWidth">長度</param>
	/// <param name="paddingChar">替代字元</param>
	/// <returns></returns>
	public static string PadLeftCHT(this string str, int totalWidth, char paddingChar) {
		string sResult = str.CutStr(totalWidth);
		int orgLen = Encoding.GetEncoding("big5").GetBytes(sResult).Length;

		if (totalWidth - orgLen > 0) {
			sResult = new string(paddingChar, totalWidth - orgLen) + sResult;
		}

		return sResult;
	}
	#endregion

	#region 字串靠左對齊 +static string PadRightCHT(this string str, int totalWidth, char paddingChar)
	/// <summary>
	/// 字串靠左對齊，以指定的字元在右側補足長度，超過則截字(中文算2碼)。
	/// </summary>
	/// <param name="totalWidth">長度</param>
	/// <param name="paddingChar">替代字元</param>
	/// <returns></returns>
	public static string PadRightCHT(this string str, int totalWidth, char paddingChar) {
		string sResult = str.CutStr(totalWidth);
		int orgLen = Encoding.GetEncoding("big5").GetBytes(sResult).Length;

		if (totalWidth - orgLen > 0) {
			sResult = sResult + new string(paddingChar, totalWidth - orgLen);
		}

		return sResult;
	}
	#endregion

	#region  取得CharCode(支援罕字)
	public static int GetCharCode(this string character) {
		UTF32Encoding encoding = new UTF32Encoding();
		byte[] bytes = encoding.GetBytes(character.ToCharArray());
		return BitConverter.ToInt32(bytes, 0);
	}
	#endregion

	#region  "字串".Len();
	//相當VB 的 String.Len()  用以取代 string.Length 可以計算 Unicode 第二字面的內碼
	/// <summary>
	/// 取得字串的長度，會先換成 UTF32再計算，可以避免第二字面的字被拆成兩組字
	/// 使用方法："字串".Len();</summary>
	/// <param name="s">待處理的字串</param>
	/// <returns>字串的文字個數</returns>
	public static int Len(this string s) {
		return Encoding.UTF32.GetByteCount(s) / 4;
	}
	#endregion

	#region  "字串".Substr(int startIndex, int length);    用以取代 string.Substring
	/// <summary>
	/// 取得指定位置、長度的子字串，字串會先轉成 UTF-32
	/// 使用方法："字串".Substr(起始位置, 擷取長度);
	/// 如果 startIndex 大於字數，則傳回 ""  (空字串)
	/// 如果 startIndex + length > 字數，則傳回由 startIndex 起之剩餘的字數
	///           </summary>
	/// <param name="s">待處理的字串</param>
	/// <param name="startIndex">擷取的起始位置，不能大於字串長度</param>
	/// <param name="length">擷取的長度，與起始位置相加，不能大於字串長度</param>
	/// <returns>字串</returns>
	public static string Substr(this string s, int startIndex, int length) {
		byte[] byte32Array = Encoding.UTF32.GetBytes(s);
		startIndex *= 4;
		length *= 4;

		if (startIndex >= byte32Array.Length) return "";
		length = (startIndex + length) > byte32Array.Length ? byte32Array.Length - startIndex : length;
		return Encoding.UTF32.GetString(byte32Array, startIndex, length);
	}

	/// <summary>
	/// 取得指定位置起算的右方所有子字串，字串會先轉成 UTF-32
	/// 使用方法："字串".Substr(起始位置);
	/// 如果 startIndex 大於字數，則傳回 ""  (空字串)</summary>
	/// <param name="s">待處理的字串</param>
	/// <param name="startIndex">擷取的起始位置，不能大於字串長度</param>
	/// <returns>字串</returns>
	public static string Substr(this string s, int startIndex) {
		return s.Substr(startIndex, Int32.MaxValue);
	}
	#endregion
}